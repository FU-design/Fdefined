### 题目一

```js
Promise.resolve(1).then(2).then(Promise.resolve(3)).then(console.log);
```

#### 分析: 考察 **Promise.resolve()** 和 **Promise.prototype.then()** 的特点

### Promise.resolve()

1. 将现有的 **对象** 转化为一个 **Promise** 对象
2. **Promise.resolve** 的参数
   - 参数是一个 **Promise** 实例
     ```
      不做任何内部改动的返回这个 Promise 实例
     ```
   - 参数是一个具有 **then** 方法的对象：
     ```
      Promise.resolve() 会将其转化为 Promise 对象返回，之后立即执行该对象自身的 then 方法
     ```
   - 参数是一个不具备 **then** 方法的对象，或者不是一个对象
     ```
      参数是个原始值，常量，或不具备 then 方法的对象，Promise.resolve() 会生成一个状态为 resolve状态的新的 Promise 对象返回；
      且其会将这个参数作为这个新的 Promise 对象，调用回调函数 then中的第一个参数 resolved 状态的回调函数的参数。
     ```
   - 不带任何参数
     ```
      会返回一个 resolve 状态的 Promise 对象。
     ```

### Promise.prototype.then()

1. 定义在 **Promise 原型对象** 中的方法
2. Promise 实例 **状态改变时的回调函数**
3. **Promise.prototype.then()** 的参数
   - 指定可选参数有两个，且都为函数：**resolved 状态** 的回调函数，**rejected 状态** 的回调函数。
   - 若参数不是一个函数，则默认传入参数为 null，则在使用 **链式的.then().then...** 操作时；参数为函数返回的值会透传到参数不是函数的 **.then()** 的下一个回调，若没有下一个回调则返回的就是该值。
4. 返回一个 **新的 Promise 实例**（不是调用该回调的 Promise 实例）
5. 链式回调（.then(...).then()）
   - 回调过程
     ```
     第一个回调函数完成以后，会返回一个新的 Promise 实例，且将返回结果作为参数，传入第二个回调函数，以此类推。
     ```

## 题目二

红灯三秒亮一次，绿灯一秒亮一次，黄灯 2 秒亮一次，意思就是 3 秒，执行一次 red 函数，2 秒执行一次 green 函数，1 秒执行一次 yellow 函数，不断交替重复亮灯，意思就是按照这个顺序一直执行这 3 个函数，这步可以就利用递归来实现。

```js
function red() {
  console.log("red");
}
function green() {
  console.log("green");
}
function yellow() {
  console.log("yellow");
}
```

#### 分析: 考察 **Promise.prototype.then()** 只有在上一个回调完成后才会执行下一个

```js
function red() {
  console.log("red");
}
function green() {
  console.log("green");
}
function yellow() {
  console.log("yellow");
}

const lightChange = (time, ops) => {
  return new Promise((resolve) => {
    setTimeout(() => {
      ops();
      resolve();
    }, time);
  });
};

const run = () => {
  Promise.resolve()
    .then(() => {
      return lightChange(3000, red);
    })
    .then(() => {
      return lightChange(1000, green);
    })
    .then(() => {
      return lightChange(2000, yellow);
    })
    .then(() => {
      run();
    });
};

run();
```

## 题目三

实现 mergePromise 函数，把传进去的数组按顺序先后执行，并且把返回的数据先后放到数组 data 中。

```js
const timeout = (ms) =>
  new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve();
    }, ms);
  });

const ajax1 = () =>
  timeout(2000).then(() => {
    console.log("1");
    return 1;
  });

const ajax2 = () =>
  timeout(1000).then(() => {
    console.log("2");
    return 2;
  });

const ajax3 = () =>
  timeout(2000).then(() => {
    console.log("3");
    return 3;
  });

const mergePromise = (ajaxArray) => {
  // 在这里实现你的代码
};

mergePromise([ajax1, ajax2, ajax3]).then((data) => {
  console.log("done");
  console.log(data); // data 为 [1, 2, 3]
});

// 要求分别输出
// 1
// 2
// 3
// done
// [1, 2, 3]
```

#### 分析: 考察 **then**回调只有在上一个回调完成后才会执行下一个和返回的值能够透传的特性。（这里的难点还是如何实现连续链式的透传回调结果）

```js
const mergePromise = (ajaxArray) => {
  // 在这里实现你的代码
  let data = [];
  let sequence = Promise.resolve();

  ajaxArray.forEach((fn) => {
    // 将每个函数都作为回调函数then的 resolve 状态的参数，则执行该函数完成后，会返回一个常量，Promise会自动将转为 Promise实例。作为下一个回调 resolve 状态的函数的参数。
    sequence = sequence.then(fn).then((res) => {
      data.push(res);
      return data;
    });
  });
  return sequecnce;
};
```

## 题目四

```js
const first = () =>
  new Promise((resolve, reject) => {
    console.log(3);

    let p = new Promise((resolve, reject) => {
      console.log(7);

      setTimeout(() => {
        console.log(5);
        resolve(6);
      }, 0);

      resolve(1);
    });

    resolve(2);

    p.then((arg) => {
      console.log(arg);
    });
  });

first().then((arg) => {
  console.log(arg);
});
console.log(4);

// 宏任务[3 7 4] | 微任务[1 2] 下一轮的任务队列[5]
```

#### 分析: 主要考察 js 的执行机制，宏任务、微任务、任务队列其优先执行的顺序
